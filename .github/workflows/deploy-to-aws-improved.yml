name: Deploy to AWS EC2 (Improved)

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
    branches:
      - main
      - develop
      - test/*
  push:
    branches:
      - main
      - develop
    paths:
      - 'docker-compose.yml'
      - '.env.example'
      - '.github/workflows/deploy-to-aws-improved.yml'
  workflow_dispatch:
    inputs:
      deploy_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set deployment tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.deploy_tag }}"
          else
            TAG="latest"
          fi
          echo "deploy_tag=$TAG" >> $GITHUB_OUTPUT
          echo "🏷️ Deploying tag: $TAG"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          
          # Base64로 인코딩된 키를 디코드 (GitHub Secrets에 Base64로 저장한 경우)
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" | base64 -d > ~/.ssh/routine-it-key.pem
          
          # 일반 텍스트로 저장된 경우 (이 라인은 주석처리)
          # echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/routine-it-key.pem
          
          # 권한 설정
          chmod 600 ~/.ssh/routine-it-key.pem
          
          # SSH 키 검증
          echo "🔍 Checking SSH key format..."
          head -n 1 ~/.ssh/routine-it-key.pem
          tail -n 1 ~/.ssh/routine-it-key.pem
          wc -l ~/.ssh/routine-it-key.pem
          
          # known_hosts 설정
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # SSH config 설정
          cat >> ~/.ssh/config << EOF
          Host ec2-instance
            HostName ${{ secrets.EC2_HOST }}
            User ${{ secrets.EC2_USER }}
            IdentityFile ~/.ssh/routine-it-key.pem
            StrictHostKeyChecking no
            IdentitiesOnly yes
            PreferredAuthentications publickey
          EOF
          chmod 600 ~/.ssh/config
          
          echo "🔐 SSH setup completed"
          
          # SSH 연결 테스트
          echo "🧪 Testing SSH connection..."
          ssh -v -i ~/.ssh/routine-it-key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful!'" || {
            echo "❌ SSH connection failed. Debug info:"
            echo "Host: ${{ secrets.EC2_HOST }}"
            echo "User: ${{ secrets.EC2_USER }}"
            echo "Key file exists: $(test -f ~/.ssh/routine-it-key.pem && echo 'Yes' || echo 'No')"
            echo "Key permissions: $(ls -la ~/.ssh/routine-it-key.pem)"
            exit 1
          }

      - name: Create .env file from secrets
        run: |
          cat > .env.production << EOF
          # Application
          APP_PORT=8080
          SPRING_PROFILES_ACTIVE=production
          
          # Database
          DB_HOST=routine-db
          DB_PORT=3306
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JPA_HIBERNATE_DDL_AUTO=${{ secrets.JPA_HIBERNATE_DDL_AUTO }}
          
          # Redis
          REDIS_HOST=routine-redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          
          # OAuth2 Kakao
          KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
          OAUTH_REDIRECT_URI=${{ secrets.OAUTH_REDIRECT_URI }}
          OAUTH_CALLBACK_URI=${{ secrets.OAUTH_CALLBACK_URI }}
          
          # CORS
          CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
          
          # Logging
          LOG_LEVEL_SQL=${{ secrets.LOG_LEVEL_SQL }}
          LOG_LEVEL_SQL_BIND=${{ secrets.LOG_LEVEL_SQL_BIND }}
          LOG_LEVEL_APP=${{ secrets.LOG_LEVEL_APP }}
          
          # Docker
          DEPLOY_TAG=${{ steps.tag.outputs.deploy_tag }}
          
          # MySQL Root Password (for docker-compose)
          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE=${{ secrets.DB_NAME }}
          EOF

      - name: Copy files to EC2
        run: |
          echo "📦 Copying deployment files to EC2..."
          
          # SSH 키 사용하여 직접 연결
          ssh -i ~/.ssh/routine-it-key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "mkdir -p /home/${{ secrets.EC2_USER }}/routine-it-backend"
          
          # Copy docker-compose.yml
          scp -i ~/.ssh/routine-it-key.pem docker-compose.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/routine-it-backend/
          
          # Copy .env file
          scp -i ~/.ssh/routine-it-key.pem .env.production ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/routine-it-backend/.env
          
          echo "✅ Files copied successfully"

      - name: Deploy to EC2
        run: |
          echo "🚀 Starting deployment to EC2..."
          
          ssh -i ~/.ssh/routine-it-key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            set -e
            
            echo "📂 Navigating to application directory..."
            cd /home/${{ secrets.EC2_USER }}/routine-it-backend
            
            # Backup current .env if exists
            if [ -f .env ]; then
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
              echo "📋 Backed up existing .env file"
            fi
            
            echo "📥 Pulling latest Docker images..."
            export DEPLOY_TAG=${{ steps.tag.outputs.deploy_tag }}
            docker-compose pull
            
            echo "🔄 Restarting application..."
            docker-compose down --remove-orphans
            docker-compose up -d
            
            echo "⏳ Waiting for application to be ready..."
            for i in {1..30}; do
              if curl -f http://localhost:8080/api/health/ping > /dev/null 2>&1; then
                echo "✅ Application is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "❌ Application failed to start within 5 minutes"
                docker-compose logs --tail=50
                exit 1
              fi
              echo "⏳ Waiting... ($i/30)"
              sleep 10
            done
            
            echo "🧹 Cleaning up old Docker images..."
            docker image prune -f
            
            echo "📊 Deployment status:"
            docker-compose ps
            
            echo "🔍 Environment variables loaded:"
            docker-compose exec -T app env | grep -E "^(SPRING_|DB_|REDIS_|JWT_|KAKAO_)" | sort
          ENDSSH

      - name: Health Check
        run: |
          echo "🔍 Running post-deployment health checks..."
          
          curl -f http://${{ secrets.EC2_HOST }}:8080/api/health/ping || {
            echo "❌ Health check failed"
            exit 1
          }
          
          echo "✅ All health checks passed!"

      - name: Notify deployment success
        if: success()
        run: |
          echo "🎉 Deployment completed successfully!"
          echo "🌐 Application is available at: http://${{ secrets.EC2_HOST }}:8080"
          echo "📚 API Documentation: http://${{ secrets.EC2_HOST }}:8080/swagger-ui/index.html"